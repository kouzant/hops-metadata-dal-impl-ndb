/*
 * Copyright (C) 2016 Hops.io
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/* 
 * File:   GenericAsyncMsg.h
 * Author: Konstantin Popov <kost@sics.se>
 *
 */

#ifndef ASYNCMSGBASE_H
#define ASYNCMSGBASE_H

/**
 * @addtogroup AsyncUpdateEventHandling
 *
 * @{
 */

#include "PoolMsgBase.h"
#include <cassert>

template<typename MsgType> class GenericMsgP2PQueueHead;
template<typename MsgType> class GenericMsgP2PQueueTail;

/// AsyncMsgBase is the "message base class" for message objects that
/// are generated by "listener threads" and processed asynchronously
/// by "message processing threads". It defines the abstract "hash
/// key" method for uniform distribution of messages over processing
/// threads (concealed behind e.g. the EventMsgAsyncHandler
/// interface), and also supports the implementation of point-to-point
/// messages queues (see GenericMsgP2PQueue.h for more details).
template<typename TopClass>
class AsyncMsgBase : public PoolMsgBase<TopClass> {
  template<typename GenericMsg> friend class GenericMsgP2PQueueHead;
  template<typename GenericMsg> friend class GenericMsgP2PQueueTail;
public:
  AsyncMsgBase() : toReclaim(false) {}
  ~AsyncMsgBase() {}

  /// The normal-case reclamation of GenericMsg objects proceeds in two
  /// "half-steps" performed by applying GenericMsg::safeToReclaim()
  /// twice; the second invocations says 'true'. 
  bool safeToReclaim() {
    if (toReclaim) {
      return (true);
    } else {
      toReclaim = true;
      return (false);
    }
  }

  /// It should be uniformly distributed. Note that the
  /// GenericMsg::hashKey() method is an interface declaration - hence
  /// the method itself should not be used.
  unsigned long hashKey() { assert(0); }

  void reinit() {		//!< equivalent to the constructor;
    PoolMsgBase<TopClass>::reinit();
    toReclaim = false;
  }

  /// saving the "source" producer (listener and its memory pool
  /// object) of the message when it is first dequeued, such that it
  /// could later be "returned" to that source for object reclamation,
  /// see SharedMemMsgPool.h for more details.
  void saveSenderIdx(unsigned char idx) { senderIdx = idx; }
  unsigned char getSenderIdx() const { return (senderIdx); }

private:
  unsigned char toReclaim;    //!< "half-step" to reclaim;
  unsigned char senderIdx;    //!< index of the sender (return queue);
};

#endif // ASYNCMSGBASE_H
